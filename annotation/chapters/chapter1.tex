\chapter{Введение}
За последние два десятилетия языки объектно-ориентированного программирования получили широкое распространение.
По состоянию на март 2022 года пять первых мест в индексе TIOBE \footnote{\url{https://www.tiobe.com/tiobe-index/}} занимают Python, C, Java, C++ и C\#.
Четыре из этих языков (за исключением C) считаются объектно-ориентированными и, как следует из индекса,
широко распространены и используются в крупномасштабных коммерческих продуктах.

\section{Объектно-ориентированные языки программирования}
Согласно \cite{oop1}, \textit{объектно-ориентированные} языки программирования - это языки, в которых основной единицей абстракции является \textit{объект}.
Объекты инкапсулируют \textit{данные}, которые являются значениями некоторого типа.
Некоторые языки, например, Java и C++, различают \textit{примитивные типы},
которые представляют низкоуровневые конструкции, такие как числа или булевы значения, и \textit{объектные типы},
которые представляют составной тип. Объекты могут также содержать операции над указанными данными,
известные как \textit{методы}. Методы могут принимать параметры и возвращать значение.

Объекты также должны подчиняться некоторым определенным свойствам. Как утверждает \cite{oop1}, "степень, в которой конкретный язык удовлетворяет этим свойствам, определяет, насколько он является объектно-ориентированным языком". Этими свойствами являются:
\begin{itemize}
      \item Инкапсуляция - объект должен представлять четко определенный интерфейс, через который он должен потребляться. Несущественные детали того, как объект реализует этот интерфейс, должны быть \textit{скрыты} от потребителя.
      \item Наследование - это механизм, с помощью которого объекты могут совместно использовать функциональность и расширять поведение других объектов. Наследование - сложный механизм, и его реализация отличается в разных языках. Согласно \cite{oop1}, "Наследование позволяет программистам повторно использовать определения ранее определенных структур. Это явно сокращает объем работы, требуемой при создании".
      \item Полиморфизм - возможность определять операции над объектами таким образом, что они могут принимать и возвращать значения нескольких типов.
      \item Динамическое (или позднее \cite{alankay}) связывание - реализация метода, который будет выполняться на объекте, выбирается во время выполнения. Это означает, что реализация, которая используется во время выполнения программы, может быть \textit{различной} от реализации типа, который известен статически (т.е. во время компиляции).
\end{itemize}

\section{Критика}

Вместе с растущим распространением, методы и языки ОО-программирования получили значительное количество обоснованной критики. Мэнсфилд \cite{oopfailed} упоминает большинство из этих жалоб, в конечном итоге утверждая, что "...с ООП-инфлектированными языками программирования, компьютерное программное обеспечение становится более
многословным, менее читаемым, менее описательным, его труднее модифицировать и поддерживать". Многие из этих критических замечаний превращаются в рекомендации, такие как знаменитый документ "Design patterns: elements of reusable object-oriented software"\cite{GOFPatterns}. Однако такие рекомендации не являются частью спецификации языка и поэтому не могут быть реализованы компилятором языка. Это приводит к тому, что эти рекомендации часто неправильно интерпретируются или используются слишком часто, особенно новичками.

\section{Инструменты анализа}.
Чтобы смягчить эту сложность и обеспечить применение хороших практик, разработчики создали множество программных инструментов. Эти инструменты можно разделить на две категории: \textbf{динамические} анализаторы и \textbf{статические} анализаторы.
\textbf{Динамические} анализаторы (также известные как \textit{профайлеры}) проверяют состояние программы в процессе ее выполнения. Динамические анализаторы собирают важную информацию о выполнении программы, такую как загрузка процессора и потребление памяти, и представляют ее в удобочитаемой форме. Эта информация очень важна в приложениях, где производительность играет важную роль. К сожалению, эти инструменты требуют выполнения анализируемой программы, что может быть дорого или даже невозможно, например, когда программа должна выполняться на специализированном оборудовании.

Напротив, \textbf{статические} анализаторы проверяют исходный код программы (или одно из его промежуточных представлений) \textit{без его выполнения}, чтобы найти общие ошибки, анти-паттерны и отклонения от принятых стилевых конвенций. Выполнение таких инструментов обычно не отнимает много времени и не требует больших затрат, поэтому они являются важной частью конвейеров непрерывной интеграции \cite{ci} и интегрированных сред разработки (IDE).
Несмотря на склонность к ложным срабатываниям, инструменты статического анализа могут с большей точностью определить место ошибки.

В отличие от динамических анализаторов, статические анализаторы работают с исходным кодом, что позволяет им проверять программу с точки зрения более высокого уровня. Это означает, что статические анализаторы могут улучшить отчетность об ошибках компиляторов языков программирования, обнаружить больше проблем и даже автоматически их устранить.

Перед анализом многие инструменты статического анализа преобразуют исходный текст целевого языка в некоторое промежуточное представление. Это делается по нескольким причинам. Как правило, это делается для того, чтобы извлечь из исходного кода информацию, необходимую для анализа. Другим распространенным случаем использования промежуточного представления является следующее
заставить статический анализатор работать с более чем одним целевым языком. В этом случае представление служит общей основой для различных анализаторов. Примерами промежуточного представления являются LLVM \cite{llvm} и Jimple \cite{vallee1998jimple} (используется в SOOT \cite{vallee2010soot}).

\section{Цель исследования}

В данной диссертации мы представляем реализацию модуля для статического анализатора объектно-ориентированных программ, который принимает на вход представление программы на языке Elegant Objects (EO)\cite{eolang} и выдает на выходе простые сообщения об ошибках. EO - это промежуточное представление, основанное на $\phi$-calculus, формальной модели, которая предназначена для унификации различной семантики объектно-ориентированных языков. Он также претендует на звание языка с минимальной многословностью, предоставляя минимально необходимый набор операций. Сочетание строгой формальной основы и сокращенного набора функций делает EO мощным промежуточным представлением для статического анализатора, который должен быть способен отлавливать многие ошибки, характерные для ОО-программ. В диссертации описана пробная реализация обнаружения двух дефектов семейства "хрупких базовых классов"\cite{fragilebaseclass}: "непредвиденная взаимная рекурсия" и "неоправданное допущение в модификаторе".

Остальная часть диссертации построена следующим образом: в главе \ref{chap:lr} рассматриваются существующие работы по поиску ошибок в ОО программах, в главе \ref{chap:met} описывается семантика ОО и то, как она может представлять объектно-ориентированные программы, в главе \ref{chap:impl} описывается реализация анализатора.Часть \ref{chap:conclusion} завершает диссертацию.
