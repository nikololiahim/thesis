\chapter{Методология}
\label{chap:met}

В этой главе описывается организация процесса исследования и внедрения. Раздел \ref{met:research} описывает процесс исследования, который предшествовал внедрению. Раздел \ref{met:development} охватывает инструменты и технологии, использованные в проекте. Наконец, раздел \ref{met:module_structure} дает краткий обзор структуры модулей проекта. 

\section{Исследование проблемы}
\label{met:research}
Прежде всего, мы изучили проблемы хрупких базовых классов, определив, какие из них будут наиболее подходящими для реализации. После того, как мы остановились на непредвиденной взаимной рекурсии и неоправданном допущении в подклассе, мы начали разрабатывать алгоритмы вместе с тестовыми примерами, которые использовались в основном для справки. Эти тестовые примеры позже стали частью окончательного набора тестов анализаторов. После того, как алгоритмы были доработаны и одобрены руководителем, мы приступили к реализации.

\section{Разработка}
\label{met:development}
Мы решили разместить репозиторий исходного кода нашего проекта на Github \footnote{\url{https://github.com/}}. Это было сделано в основном потому, что команда уже была знакома с этой платформой, и все необходимые настройки требовали минимальных усилий. Еще одним аспектом Github, который привлек наше внимание, была функция под названием Github Actions \footnote{\url{https://github.com/features/actions}}. Эта функция позволила легко разработать и интегрировать конвейеры непрерывной интеграции \cite{ci} и непрерывного развертывания \cite{cd} в наш репозиторий без необходимости использования самостоятельных хостинговых решений. Эти конвейеры были сконфигурированы таким образом, чтобы они запускались при каждом отправлении в мастер-ветку, отклоняя отправку, если исходный код не прошел тесты, компиляцию или линтинг. Такая конфигурация гарантирует, что код в мастер-ветке будет соответствовать стандартам качества в любой момент времени в процессе разработки. 

Реализация анализаторов была полностью выполнена на \textbf{Scala} \footnote{\url{https://www.scala-lang.org/}} - современном языке программирования с поддержкой высокоуровневых концепций, таких как структурное сопоставление шаблонов \cite{pattern_matching} и алгебраические типы данных \cite{adts}. Scala компилируется в байт-код виртуальной машины Java (JVM). Это позволяет использовать реализацию в качестве библиотеки в любом другом проекте, совместимом с JVM, будь то Scala или Java. Кроме того, программы, скомпилированные в байт-код JVM, могут быть запущены без изменений на любом устройстве, на котором может работать Java Virtual Machine.

В проекте используется инструмент сборки под названием \textbf{sbt} \footnote{\url{https://www.scala-sbt.org/}}, который позволяет компилировать несколько модулей Scala одновременно. Отличительной особенностью \textbf{sbt} является возможность кросс-компиляции кода Scala, благодаря чему он совместим со многими версиями Scala и Java. Он также поддерживает множество плагинов, которые улучшают процесс разработки. Мы использовали два таких плагина: \textbf{scalafmt} \footnote{\url{https://scalameta.org/scalafmt/}}, автоматический форматтер исходного кода, и \textbf{scalafix} \footnote{\url{https://scalacenter.github.io/scalafix/}} , линтер и анализатор кода с поддержкой рефакторинга в рамках всего проекта.

Анализаторы публикуются в виде \textbf{JAR} \footnote{\url{https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html}} и могут быть загружены из репозитория \textbf{Maven Central} \footnote{\url{https://search.maven.org/search?q=g:org.polystat.odin}}.

Исходный код проекта доступен на \textbf{Github} \footnote{\url{https://github.com/polystat/odin}}. Там же можно найти инструкции по запуску и внесению вклада в проект.


\section{Структура модуля}
\label{met:module_structure}
Исходный код анализаторов был разделен на несколько модулей:
\begin{itemize}
    \item Core, который содержит определение для EO AST (Abstract Syntax Tree).
          Это AST используется в качестве входных данных для всех алгоритмов анализа.
    \item Analyses, которая содержит реализации анализаторов.
    \item Backends, которая содержит алгоритмы, преобразующие EO AST во что-то другое. Пока что единственным бэкендом является бэкенд обычного текста: он преобразует EO AST в его синтаксически корректный эквивалент в исходном коде EO. Этот бэкенд также может быть интерпретирован как красивый принтер кода EO и широко используется в качестве такового в других модулях.
    \item Parser, который содержит парсер (также известный как синтаксический анализатор) исходного кода EO. Он используется для преобразования различных представлений EO (например, обычного текста или кодировки XML) в синтаксическое дерево EO, определенный в модуле Core.
\end{itemize}
