\chapter{Implementation}
\label{chap:impl}
This chapter analyzes specifics of Odin (short for Object Dependency INspector) - a static analyzer of EO source code. Section 4.1 covers the tools and technologies used in the project. Section 4.2 gives a brief overview of the project file structure.
Section 4.3 goes over the implementation of EO parser used in the project. Section 4.4 discusses the ways we can represent the elements of object-oriented programs in EO. Sections 4.5 and 4.6 describe the implementations of the analysis algorithms applied to structured EO code. Finally, section 4.7 summarizes this chapter.

\section{Development Environment}
Odin is a project written entirely in \textbf{Scala} \footnote{\url{https://www.scala-lang.org/}} - a modern programming language with support for high-level concepts such as structural pattern matching and algebraic data types. Scala is compiled into Java Virtual Machine (JVM) byte code. This allows Odin to be used as a library in any other project compatible with JVM, be it Scala or Java. In addition, programs compiled to JVM byte code can be run without changes on any device that can run Java Virtual Machine.


The project uses a build tool called \textbf{sbt} \footnote{\url{https://www.scala-sbt.org/}}, which allows compiling multiple Scala modules at once. A distinctive feature of \textbf{sbt} is the ability to cross-compile Scala code so that it is compatible with many versions of Scala and Java. It also supports a variety of plugins that improve the development process. The plugins used by Odin are \textbf{scalafmt} \footnote{\url{https://scalameta.org/scalafmt/}}, an automatic source code formatter, and \textbf{scalafix} \footnote{\url{https://scalacenter.github.io/scalafix/}} , a linter and code analyzer with support for project-wide refactorings.

Odin is published as a \textbf{JAR} \footnote{\url{https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html}} and can be downloaded from the \textbf{Maven Central} repository \footnote{\url{https://search.maven.org/search?q=g:org.polystat.odin}}.

The source code of the project is available on \textbf{Github} \footnote{\url{https://github.com/polystat/odin}}. It also provides the instructions on how to launch and contribute to the project.



\section{Module Structure}
Odin is a project consisting of multiple modules. The main modules are:
\begin{itemize}
    \item Core, which contains the definition for EO AST (Abstract Syntax Tree).
          This AST is used as an input to all analysis algorithms.
    \item Analyses, which contains the implementations of various analyzers.
    \item Backends, which contains algorithms that transform EO AST into something else. The only backend so far is a plain text backend: it transforms EO AST into its syntactically correct equivalent in EO source code. This backend can also be interpreted as a pretty-printer of EO code and is widely used as such in other modules.
    \item Parser, which contains a parser (also known as a syntactic analyzer) of EO source code. It is used to convert different EO representations (e.g. plain text or XML encoding) into the EO AST defined in Core module.
\end{itemize}
\section{Parser}
The parser used in Odin implements a slightly altered version of EO specification defined by Bugayenko \cite{eolang}. In particular, it relaxes constraints on whitespace between tokens and the number of newlines and comments between definitions. This is done to reduce the complexity of producing source code pieces for testing and debugging.


The parser was created using \textbf{cats-parse} library \footnote{\url{https://github.com/typelevel/cats-parse}} for Scala. It provides a parser-combinator \cite{hill_combinators_1996} approach to building recursive-descent parsers. Recursive-descent parsers are known for their worst-case exponential complexity. This problem can not be avoided in general. However, cats-parse mitigates it by explicitly marking all the places in the parser definition that can cause such spikes in complexity.

\section{Analyses}
This section describes each of the analysis algorithms in greater detail. First, we will describe the steps that are performed prior to each of the defect-specific analyses: parsing and detecting the significant features of EO programs - objects, methods and extension clauses. Then we will describe the algorithms for detecting each of the covered defects: unanticipated mutual recursion and unjustified assumption in subclass. Finally, we will conclude the chapter by describing the shortcomings of each of the algorithms.


\subsection{Preprocessing}
Before running on


\subsection{Unanticipated Mutual Recursion}

\subsection{Unjustified Assumption Analysis}

\subsection{Shortcomings of the algorithms}
