\chapter{Обзор литературы}
\label{chap:lr}
\chaptermark{Заголовок второй главы}
В этой главе представлен обзор теоретических концепций, на которые опирается реализация. Раздел \ref{lit:phicalc} кратко описывает соответствующие части $\varphi$-исчисления: его синтаксис и семантику. Раздел \ref{lit:eo} объясняет, как $\varphi$-исчисление отображается на EO, промежуточное представление, на котором работают анализаторы. Раздел \ref{lit:encoding} показывает, как кодировать основные объектно-ориентированные конструкции (классы, методы, наследование) с помощью EO. 

\section{Методы \& Критерии}.
Работы, связанные с $\varphi$-исчислением и EO, появились сравнительно недавно и в основном не опубликованы. Те работы, которые уже опубликованы, были предоставлены научным руководителем. Препринты неопубликованных работ были любезно предоставлены авторами. 

\section{$\varphi$-исчисление}
\label{lit:phicalc}

EO - это язык программирования, реализующий $\varphi$-calculus, формальную модель для объектно-ориентированных языков программирования, первоначально представленную Бугаенко \cite{eolang}. В этой диссертации мы используем уточнение $\varphi$-calculus, предложенное Кудасовым и Сим \cite{kudasov}.

\subsection{Объекты и атрибуты}
В основе $\varphi$-исчисления лежит понятие \textbf{объект}.

\begin{definition}[Объекты и атрибуты].
    \textbf{Объект} - это набор пар $\mkObject{n_0 \mapsto o_0, n_1 \mapsto o_1, \hdots, n_i \mapsto o_i, \hdots}$, где $n_i$ - уникальный идентификатор, а $o_i$ - объект. Такие пары известны как \textbf{атрибуты}. Первый элемент - это \textbf{имя атрибута}, второй элемент - \textbf{значение атрибута}. Пустой набор $\mkObject{}$ также является допустимым объектом. Атрибут, в котором вторым элементом является $\mkObject{}$, называется \textbf{void} или \textbf{free}. В противном случае он называется \textbf{attached}.
\end{definition}

Атрибуты объекта могут быть доступны по их именам через точечную нотацию:
\begin{align*}
    \mkObject{x \mapsto y}.x \rightsquigarrow y
\end{align*}
В данном случае, это сводится к объекту $y$, который определен в другом месте. $\rightsquigarrow$ означает "сводится к" или "вычисляется в".

\subsection{Аппликация}
Аппликация может быть использована для создания нового объекта, в котором заданы значения некоторых или всех свободных атрибутов. Другими словами, применение может быть использовано для создания \textit{закрытых} объектов из \textit{абстрактных} объектов.

\begin{definition}[Абстрактные и закрытые объекты].
    Если объект имеет один или несколько свободных атрибутов, он называется \textbf{abstract} или \textbf{open}. В противном случае, он называется \textbf{закрытый}.
\end{definition}

Например, объект $a$ в \ref{lit:app} соответствует точке в двумерном пространстве с координатами $x = 1$, $y = 2$. Объекты $1$ и $2$ могут быть определены в терминах $\varphi$-исчисления, однако само определение выходит за рамки данной диссертации.

\begin{align}
    point := \mkObject{x \mapsto \mkObject{}, y \mapsto \mkObject{}} \\
    \label{lit:app}
    a := point(x \mapsto 1, y \mapsto 2) \\\\
    a \rightsquigarrow \mkObject{x \mapsto 1, y \mapsto 2}
\end{align}


\subsection{Локаторы}

Пересмотр $\varphi$-исчисления Кудасовым и Сим \cite{kudasov} также определяет специальные объекты, называемые \textbf{локаторами}, которые обозначаются как $\rho^i$, где $i \in \mathbb{N}$. Локаторы позволяют объектам ссылаться на другие объекты относительно объекта, в котором используется локатор. Например, это может быть использовано для (но не ограничивается этим) кодирования определения атрибутов в терминах других атрибутов данного объекта. Предположим, есть объект $x$:
\begin{align*}
    x := \mkObject{a \mapsto \rho^0.b, b \mapsto c}
\end{align*}
Выражение $x.a$ будет сведено к значению объекта $c$. Это происходит потому, что $x.a$ ссылается на $x.b$ через $\rho^0$, что означает непосредственный объемлющий объект. В более сложных примерах, таких как \ref{lit:complex}.

\begin{align}
    \label{lit:complex}
    x := \mkObject{a \mapsto \mkObject{c \mapsto \rho^1.b}, b \mapsto d} \\
    x.a.c \rightsquigarrow d
\end{align}

$\rho$ можно использовать для определения атрибутов внутренних объектов в терминах атрибутов внешних объектов, или даже самих внешних объектов.

\subsection{$\varphi$-атрибут}
Объекты могут определять специальный атрибут с именем $\varphi$. Этот атрибут перенаправляет доступ к атрибуту на его значение, если у окружающего объекта нет атрибута с таким именем (рис. \ref{lit:phi}).

\begin{align}
    \label{lit:phi}
    a := \mkObject{d \mapsto y}                    \\
    \label{lit:decorated}
    x := \mkObject{\varphi \mapsto a, c \mapsto g} \\
    x.d \rightsquigarrow x.\varphi.d \rightsquigarrow y
\end{align}

Если атрибут присутствует и в объекте, и в его $\varphi$-атрибуте, приоритет имеет атрибут в объекте:
\begin{align*}
    a := \mkObject{d \mapsto y}                             \\
    x := \mkObject{\varphi \mapsto a, \textbf{d} \mapsto g} \\
    x.d \rightsquigarrow g
\end{align*}

В \ref{lit:decorated}, Бугаенко \cite{eolang} называет объект $a$ \textbf{декорированный объект}, где часть "декорированный" относится к шаблону декоратора, описанному в \cite[Глава 4]{GOFPatterns}. Эта техника расширения объекта также известна как \textit{делегирование}. \cite{raiha_delegation:_1994} в объектно-ориентированных языках.

\subsection{Сложный пример}.
Связывая все воедино, рисунок \ref{fig:fibo} показывает, как $\varphi$-исчисление может быть использовано для вычисления чисел Фибоначчи.

\input{figs/fibonacci}

% \subsection{Dataization}
% $\varphi$-атрибут играет важную роль в процессе \textit{dataization}, который является термином, придуманным Бугаенко в \cite{eolang}, который описывает оценку программы EO.

\section{EO}
\label{lit:eo}
EOLANG, или просто EO, - это язык программирования, созданный Бугаенко \cite{eolang}, который является прямой реализацией $\varphi$-calculus с некоторыми расширениями. Однако их реализация содержит особенности, которые не имеют отношения к теме данной диссертации. Более того, существует заметное различие между версией EO Бугаенко и $\phi$-исчислением \cite{kudasov} в определении локаторов (или "родительских объектов"). В работе Бугаенко локаторы являются \textit{атрибутами}, тогда как в работе \cite{kudasov} они являются \textit{объектами}. В данной диссертации, по аналогии с $\varphi$-исчислением, мы будем использовать другую версию EO, которая является прямым переводом исчисления, определенного в \ref{lit:phicalc}. Таблица перевода показана на рисунке \ref{fig:phitoeo}.

\input{figs/phitoeo}

\section{Описание объектно-ориентированных программ с помощью EO}
\label{lit:encoding}
Прежде чем анализировать программы, написанные на объектно-ориентированных языках программирования, необходимо перевести их в EO, сохранив семантику исходного языка. В этом разделе представлена упрощенная версия такой кодировки, которая предполагается анализаторами, описанными в данной диссертации. Кодировка была в значительной степени заимствована из \cite{bugayenko_reducing_2021} с некоторыми изменениями, направленными в основном на упрощение процесса анализа.

\subsection{Классы}
Классы моделируются как закрытые объекты EO. Атрибуты уровня класса (т.е. "статические") становятся атрибутами объекта класса. Конструктор представлен атрибутом-объектом "new" объекта класса. Этот объект может принимать параметры для создания экземпляра объекта.

Все атрибуты и методы экземпляра определяются внутри объекта, возвращаемого объектом "new". В EO наследование моделируется как украшение. Экземпляры классов (они же объекты в Java) создаются
путем применения объекта "new" к требуемым параметрам.

\subsection{Методы}
Методы моделируются как объекты EO, аналогично классам. Эти объекты могут принимать параметры.
Методы экземпляра должны принимать специальный атрибут \textbf{self} в дополнение к другим параметрам. Этот параметр используется для передачи экземпляра объекта, вызывающего метод (отсюда и название - "self").
Параметр "self" можно использовать для вызова методов экземпляра внутри других методов экземпляра. Вызов метода принимает следующий вид:
\begin{lstlisting}
    self.method_name self arg1 arg2 и т.д.
\end{lstlisting}

Возвращаемое значение метода представлено значением атрибута $\varphi$ (символ "@" в EO). Для того чтобы вызвать метод экземпляра, нам необходимо сначала инстанцировать объект. Затем мы можем вызвать метод, обратившись к атрибуту экземпляра с именем метода и передав ему объект экземпляра в качестве первого аргумента.

\subsection{Примеры перевода}
Примеры такого перевода, примененного к простым Java-программам, можно найти в последующих разделах, а именно на рисунках \ref{fig:mutualrec_basic} и \ref{fig:unjustified_before}.
\section{Проблема хрупкого базового класса}

\subsection{Непредсказуемая взаимная рекурсия}
Непредвиденная взаимная рекурсия - это проблема, которая возникает в результате неограниченного наследования. Предположим, у нас есть объект Base с двумя методами - $f$ и $g$. Метод $g$ вызывает метод $f$, а $f$ - нет.


Затем существует класс Derived, который расширяет Base и переопределяет метод $f$ таким образом, что он вызывает $g$. Когда мы вызываем метод $f$ на экземпляре Derived, мы получаем ошибку переполнения стека: метод $f$ вызывает метод $g$, метод $g$ вызывает метод $f$ и так далее \pic{fig:mutualrec_basic}.

Важно отметить, что мы не заинтересованы в обнаружении взаимной рекурсии между двумя методами одного класса. Нас интересуют только те случаи, когда взаимная рекурсия возникает в результате переопределения одного из методов суперкласса. Пример \pic{fig:oddeven} показывает класс с двумя взаимно рекурсивными методами \textit{isOdd} и \textit{isEven}. В данном случае рекурсия ожидаема и необходима, поэтому она не является дефектом.

\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting[language=Java]{code/mutualrec.java}
        \caption{Java}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting{code/mutualrec.eo}
        \caption{EO}
    \end{subfigure}
    \caption{Пример непредвиденной взаимной рекурсии}
    \label{fig:mutualrec_basic}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting[language=Java]{code/NumericOps.java}
        \caption{Java}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting{code/numeric_ops.eo}
        \caption{EO}
    \end{subfigure}
    \caption{Пример без непредвиденной взаимной рекурсии.}
    \label{fig:oddeven}
\end{figure}

\subsection{Необоснованное предположение в подклассе}.
Этот дефект \cite[Раздел 3.3]{fragilebaseclass} возникает, когда суперкласс рефакторят путем \textit{инлайнинга} вызовов метода, который может быть переопределен подклассом. Термин инлайнинг означает замену вызова метода его телом. Рассмотрим пример \pic{fig:unjustified_before}. Класс $M$ расширяет класс $C$, переопределяя метод $l$, чтобы ослабить его предусловие. Следовательно, предусловие в методе $m$ класса $M$ также ослаблено, потому что оно зависит от вызова метода $l$.

Теперь предположим, что класс $C$ пришел из некоторой внешней библиотеки, а класс $M$ определен в пользовательском коде. Сопровождающий библиотеки решает рефакторить класс $C$, инлайнируя вызов $l$ в методе $m$ \pic{fig:unjustified_after}. Понаблюдайте, что происходит с классом $M$. Теперь, когда $m$ в классе base имеет assert, переопределение метода $n$ в классе $M$ имеет усиленное предусловие по сравнению с его версией в классе $C$. Поэтому, казалось бы, безопасный рефакторинг в базовом классе нарушил инварианты в подклассах. Название дефекта происходит от того, что подклассы обычно $M$ \textit{предполагают}, что метод $m$ должен быть реализован через метод $l$. Примеры на рис. \ref{fig:unjustified_before} и \ref{fig:unjustified_after} показывают, что такое предположение действительно не оправдано, и сопровождающие класса $C$ могут изменить его по своему усмотрению.

\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting[language=Java]{code/Unjustified.java}
        \caption{Java}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting{code/unjustified.eo}
        \caption{EO}
    \end{subfigure}
    \caption{Пример необоснованного предположения в подклассе (до пересмотра)}
    \label{fig:unjustified_before}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting[language=Java]{code/UnjustifiedRevised.java}
        \caption{Java}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.4\textwidth}
        \lstinputlisting{code/unjustified_revised.eo}
        \caption{EO}
    \end{subfigure}
    \caption{Пример необоснованного предположения в подклассе (после пересмотра)}
    \label{fig:unjustified_after}
\end{figure}



\newpage
